/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <ctype.h>
#include <fcntl.h>
#include <linux/limits.h>
#include <linux/kernel.h>
#include <regex.h>
#include <stdbool.h>
#include <sys/sysinfo.h>
#include <unistd.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "dynamicRatioProcess.h"

static int counter_regexps_on_process_cmd_line = 0;

static regex_t regexps_on_proc_cmd_line[MAX_NUMBER_REGEXPS_ON_PROC_CMD_LINE];

static
void config_handle_LbDWRRregexpCmdLine(const char *key, char *value) {
    if (strcasecmp(CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE, key) != 0)
        return;

    if (counter_regexps_on_process_cmd_line >=
              MAX_NUMBER_REGEXPS_ON_PROC_CMD_LINE) {
        // TODO: report a warning: "too many regexps requested in snmpd.conf"
        //       so discarding this "value"
        return;
    }
    int res = regcomp(
                &regexps_on_proc_cmd_line[counter_regexps_on_process_cmd_line],
                value, REG_EXTENDED
              );
    if (res != 0) {
         // TODO: report a warning on an invaled extended reg-exp "value"
         return;
    }

    // If regcomp() was successful, then increment the counter
    counter_regexps_on_process_cmd_line ++;
}

static
void config_free_LbDWRRregexpCmdLine(void) {

    for (int i=0; i < counter_regexps_on_process_cmd_line; i++) {
        regfree(&regexps_on_proc_cmd_line[i]);
    }

    counter_regexps_on_process_cmd_line = 0;
}


/** Initializes the dynamicRatioProcess .SO module for the SNMPD agent */
void
init_dynamicRatioProcess(void)
{
    const oid dynamicRatioProcessCpu_oid[] = { 1,3,6,1,4,1,99999,3,1 };
    const oid dynamicRatioProcessMemory_oid[] = { 1,3,6,1,4,1,99999,3,2 };

  DEBUGMSGTL(("dynamicRatioProcess", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessCpu",
                               handle_dynamicRatioProcessCpu,
                               dynamicRatioProcessCpu_oid,
                               OID_LENGTH(dynamicRatioProcessCpu_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessMemory",
                               handle_dynamicRatioProcessMemory,
                               dynamicRatioProcessMemory_oid,
                               OID_LENGTH(dynamicRatioProcessMemory_oid),
                               HANDLER_CAN_RONLY
        ));

    snmpd_register_config_handler(
        CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE,
        config_handle_LbDWRRregexpCmdLine,
        config_free_LbDWRRregexpCmdLine,
        CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE " <extend-reg-expr>"
        "\n\n"
        "# Specify a extended regular expression to match on the process' "
        "command-line to identify\n"
        "# only those processes to report to the load-balancer for its "
        "dynamic weighted round-robin.\n"
        "# That extended regular expression will be matched on any substring "
        "in /proc/*/cmdline.\n"
        "# " CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE " can be specified multiple "
        "times, meaning to match\n"
        "# at least any of the reg-exprs indicated."
    );
}


// TODO: Review backend process metrics. These also include contextual
//       metrics about the health of the container, virtual machine
//       and/or hypervisor, like using Kubernetes Metrics API or
//       from DRS.
static struct backend_process_metrics {
    u_long   metric_cpu;
    u_long   metric_memory;
    // ... other metrics (weights) relevant for the dynamic weighted round
    // robin in the load balancer.

    // struct timespec last_time_updated;
    // "last_time_updated" is to avoid querying backend information sources
    // which don't update its information 10-20 second like the load balancer
    // queries these weights, but only every N minutes, like DRS (5 minutes
    // by default)
} my_backend_process_metrics;


static
long
get_pid_cpu_stats(int process_id) {

    unsigned long utime;   // the signed or unsigned long is given by...
    unsigned long stime;   // format specifier %lu or %ld in proc(5) ...
    long          cutime;  // (`man 5 proc` for "/proc/[pid]/stat")
    long          cstime;

    // Inspired by Sebastien Godard's "pidstat" read_proc_pid_stat()
    // https://github.com/sysstat/sysstat/blob/master/pidstat.c#L356
    char pid_stat_fname[PATH_MAX+1];
    int  pid_stat_fd;
    char pid_stat_contents[5000];
    int contents_read;

    sprintf(pid_stat_fname, "/proc/%d/stat", process_id);

    if ((pid_stat_fd = open(pid_stat_fname, O_RDONLY)) < 0)
        return -1;

    contents_read = read(pid_stat_fd, pid_stat_contents,
                         sizeof pid_stat_contents - 1);
    close(pid_stat_fd);
    if (contents_read <= 0)
       return -2;
    pid_stat_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/stat" till a field after "cstime"
    // (http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_stat_contents,
           "%*d %*s %*c %*d %*d %*d "    // (1) pid ... till ... (6) session
           "%*d %*d %*u %*u %*u %*u " // (7) tty_nr .. till .. (12) majflt
           "%*u %lu %lu %ld %ld %*d ", // (13) cmajflt .till .. (18) priority
           &utime, &stime, &cutime, &cstime);

    if (rd != 4)   // couldn't read the four fields above
        return -3;
    else
        return (utime + stime + cutime + cstime);   // we could split these
                          // values if the load balancer were to be interested
                          // in, e.g., specifically the user time "utime" spent
                          // by this backend process, or the kernel time
                          // "stime" spent by it.
}

static
long
get_os_uptime(void) {
    struct sysinfo kern_info;
    int result = sysinfo(&kern_info);
    if (result != 0)
        return -1;
    else
        return kern_info.uptime;
}

static
unsigned long long
get_pid_start_time_ticks(int process_id) {

    unsigned long long start_time_ticks;

    char pid_stat_fname[PATH_MAX+1];
    int  pid_stat_fd;
    char pid_stat_contents[5000];
    int contents_read;

    sprintf(pid_stat_fname, "/proc/%d/stat", process_id);

    if ((pid_stat_fd = open(pid_stat_fname, O_RDONLY)) < 0)
        return 0;

    contents_read = read(pid_stat_fd, pid_stat_contents,
                         sizeof pid_stat_contents - 1);
    close(pid_stat_fd);
    if (contents_read <= 0)
       return 0;
    pid_stat_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/stat" till a field after
    // "starttime" (which itself is the field #22 according to
    // doc: http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_stat_contents,
           "%*d %*s %*c %*d %*d %*d "    // (1) pid ... till ... (6) session
           "%*d %*d %*u %*u %*u %*u " // (7) tty_nr .. till .. (12) majflt
           "%*u %*u %*u %*d %*d %*d "  // (13) cmajflt till (18) priority
           "%*d %*d %*d %llu %*u ", // (19) nice ... till ... (23) vsize
           &start_time_ticks);

    if (rd != 1)   // couldn't read the field above
        return 0;
    else
        return start_time_ticks;
}

/*
 * Returns the RSS size (in KB) of a process-id. If there is an error, it
 * returns a negative number instead.
 */

static
long
get_pid_rss_mem_kb(int process_id) {

    long rss_mem_pages;

    char pid_statm_fname[PATH_MAX+1];
    int  pid_statm_fd;
    char pid_statm_contents[5000];
    int contents_read;

    sprintf(pid_statm_fname, "/proc/%d/statm", process_id);

    if ((pid_statm_fd = open(pid_statm_fname, O_RDONLY)) < 0)
        return -1;

    contents_read = read(pid_statm_fd, pid_statm_contents,
                         sizeof pid_statm_contents - 1);
    close(pid_statm_fd);
    if (contents_read <= 0)
       return -2;
    pid_statm_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/statm" till a field after "resident"
    // (ie., till the field "shared")
    // doc: http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_statm_contents,
           "%*d %ld %*d ",   // (1) size (2) resident (3) shared
           &rss_mem_pages);

    if (rd != 1)   // couldn't read the field above
        return -3;
    else {
        long bytes_in_page = sysconf(_SC_PAGESIZE);
        return (rss_mem_pages * bytes_in_page / 1024);
    }
}

/*
 * Returns the available memory (in KB) in Linux. If there is an error, it
 * returns a negative number instead.
 *
 * About /proc/meminfo (in `man 5 proc`):
 *
 *    Field:
 *
 *         MemAvailable %lu (since Linux 3.14)
 *
 *              An estimate of how much memory is available for starting new
 *              applications, ____without swapping____.
 *
 *              (___Underscore___ above is ours, since it is relevant for the
 *               load-balancer to know when to send requests to a backend
 *               process ___without making it swap___.)
 *
 * The `free` program returns the field "MemFree" in the "free" column, and
 * and returns the field "MemAvailable" in the "available" column.
 *
 * The field "MemAvailable" in /proc/meminfo exists since Linux kernel version
 * 3.14 (released on 30 March 2014) or higher, and some major distributions
 * don't release yet with this kernel version by default.
 *
 * So we prefer to use the field "MemAvailable" in /proc/meminfo if it is found
 * there. If it is not found, then use the field "MemFree". An alternative is
 * to call "uname(struct utsname *buf)" to check the version of kernel, and if
 * it is >= 3.14, then to search for "MemAvailable" in /proc/meminfo, otherwise
 * to search for "MemFree".
 */

static
long
get_linux_avail_mem_kb(void) {

    long avail_mem_kb = -1;
    FILE * proc_meminfo;
    char line[256];

    if ((proc_meminfo = fopen("/proc/meminfo", "r")) == NULL)
        return -2;

    while (fgets(line, sizeof(line), proc_meminfo)) {
        bool this_is_mem_avail = false; // if this is "MemAvailable: "
        char * token_start;             // start of the field-name token
        if ((token_start = strstr(line, "MemAvailable: ")) != NULL) {
            this_is_mem_avail = true;
        } else {
            token_start = strstr(line, "MemFree: ");
        }
        if (token_start == NULL)
            continue;   // another token we are not interested in
        else if (token_start != line)
            continue;  // the token was found, but not at the start of line

        // skip the token (field-name) till the first space following it
        for (; *token_start != '\0' && *token_start != ' '; token_start ++);
        // then skip all the spaces before the numeric value
        for (; *token_start != '\0' && *token_start == ' '; token_start ++);

        long value;
        int rd = sscanf(token_start, "%ld", &value);
        if (rd != 1)   // couldn't read the numeric field above
            continue;  // skip this line
        // skip the digits of the value
        for (; *token_start != '\0' && isdigit(*token_start); token_start ++);
        // skip the spaces before the [optional] unit of measurement
        for (; *token_start != '\0' && *token_start == ' '; token_start ++);

        // try to understand the [optional] unit of measurement of the value
        if (*token_start == 'm' || *token_start == 'M')       // MBs
            avail_mem_kb = value * 1024;
        else if (*token_start == 'g' || *token_start == 'G')  // GBs
            avail_mem_kb = value * 1024 * 1024;
        if (*token_start == 'k' || *token_start == 'K' || // KBs, or
            *token_start == '\n' || *token_start == '\0') // no unit of measure
            avail_mem_kb = value;     // KBs is the default unit, if omitted
        else
            continue;   // TODO:
                        // error: it is a unit of measurement we didn't know

        if (this_is_mem_avail)
            break;     // the value of "MemAvailable:" is immediately good
    }

    fclose(proc_meminfo);
    return avail_mem_kb;
}


int
handle_dynamicRatioProcessCpu(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            ;
            /* TODO: update CPU backend process metric in
             *       struct my_backend_process_metrics above from the local
             *       /proc/<backend_pid>/stat file.
             *       For other metrics, it may be necessary to query other
             *       APIs, like for cluster-wide metrics/recommendations
             *       from Kubernetes Metrics API, DRS, etc, waiting
             *       probably N minutes before refreshing our internal
             *       values from these systems, which don't update their
             *       metrics every 10-20 seconds that the load balancer
             *       queries for the current dynamic metrics. */

            /* TODO 2: use "regexps_on_proc_cmd_line" to find out which pids'
             *         whose metrics to gather. */
            int pid = 1;   // Placeholder "pid = 1"
                           // TODO: find the real process-ID of the backend
                           //       process that the load-balancer is
                           //       interested in to find its CPU availability.

            long pid_cpu_usage_ticks = get_pid_cpu_stats(pid);

            long os_uptime = get_os_uptime();
            // TODO: ERROR checking: if (os_uptime < 0) ERROR

            // this call down here, we don't need to call it each time that
            // "handle_dynamicRatioProcessCpu" is called for an SNMP GET
            // request, since it is constant after initialization
            long hertz = sysconf(_SC_CLK_TCK);

            // this call below is not necesarily constant, since the "pid" may
            // die and another "pid" (process), for the same backend program,
            // may start. Ie., the "pid" may change across calls to
            // "handle_dynamicRatioProcessCpu"
            unsigned long long pid_start_time_ticks =
                                              get_pid_start_time_ticks(pid);
            // TODO: ERROR checking: if (pid_start_time_ticks == 0) ERROR

            // how long this process has been running (in seconds)
            long running_seconds = os_uptime - (pid_start_time_ticks / hertz);

            int pid_cpu_usage_percentage =
                     (( 100 * pid_cpu_usage_ticks) / hertz) / running_seconds;
            // TODO: the above two calculations find the CPU% used by the
            // "pid" since the beginning of thee program. Pbby another way
            // would be to find the CPU% used by the process _since_ the last
            // call to this function "handle_dynamicRatioProcessCpu", since it
            // is supposed that the Load-Balancer took some decision on how
            // much traffic to send to this backend process since the last call
            // to this (SNMP) function (using dynamic weighted round-robin).
            // If "pid" has changed since the last call to this function, or if
            // this is the first time that this function has ever been called,
            // then we would use the above value "pid_cpu_usage_percentage".

            // TODO: We can't truly use assert() here because this is a
            // Net-SNMP .SO extension, but in idea:
            //
            // assert( 0 <= pid_cpu_usage_percentage );
            // assert( pid_cpu_usage_percentage <= 100 );

            my_backend_process_metrics.metric_cpu =
                                             (u_long) pid_cpu_usage_percentage;

            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_cpu,
                         sizeof(my_backend_process_metrics.metric_cpu));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessCpu\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dynamicRatioProcessMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            ;
            /* TODO: update memory backend process metric, reading
             *       /proc/<backend_pid>/{status,statm,maps,smaps}.
             *       See also as well comment for the CPU backend process
             *       metric. */

            /* TODO 2: use "regexps_on_proc_cmd_line" to find out which pids'
             *         whose metrics to gather. */

            int pid = 1;   // Placeholder "pid = 1"
                           // TODO: find the real process-ID of the backend
                           //       process that the load-balancer is
                           //       interested in to find its RSS RAM
                           //       availability.

            // we can either return to the load-balancer the memory size of
            // the process (so the bigger the backend process, probably the
            // less its weight in the load-balancer -if the load-balancer
            // gives any weight to the memory size of the backend process);
            // OR:
            // return the available memory in the (Linux) system (so the more
            // the memory still available, then the higher weight this backend
            // process should have in the load-balancer, all other dimensions
            // being the same). NOTE: This second for is irrelevant for
            // JVM -alike- backend processes with max heap size "-Xmx", or with
            // backend processes with a memory-limit (ulimit -v ...), or
            // running under a Linux control group, "cgcreate -g memory:..."

            long rss_pid_kb = get_pid_rss_mem_kb(pid);  // the RSS (in KB)
            long system_avail_mem_kb = get_linux_avail_mem_kb();

            my_backend_process_metrics.metric_memory = rss_pid_kb; // the first

            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_memory,
                         sizeof(my_backend_process_metrics.metric_memory));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessMemory\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
