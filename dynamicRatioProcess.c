/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <linux/kernel.h>
#include <sys/sysinfo.h>
#include <unistd.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dynamicRatioProcess.h"


// TODO: Review backend process metrics. These also include contextual
//       metrics about the health of the container, virtual machine
//       and/or hypervisor, like using Kubernetes Metrics API or
//       from DRS.
static struct backend_process_metrics {
    u_long   metric_cpu;
    u_long   metric_memory;
    // ... other metrics (weights) relevant for the dynamic weighted round
    // robin in the load balancer.

    // struct timespec last_time_updated;
    // "last_time_updated" is to avoid querying backend information sources
    // which don't update its information 10-20 second like the load balancer
    // queries these weights, but only every N minutes, like DRS (5 minutes
    // by default)
} my_backend_process_metrics;


static
long long
get_pid_cpu_stats(int process_id) {

    unsigned long long utime;   // the signed or unsigned long is given by...
    unsigned long long stime;   // format specifier %lu or %ld in proc(5) ...
    long long          cutime;  // (`man 5 proc` for "/proc/[pid]/stat")
    long long          cstime;

    // Inspired by Sebastien Godard's "pidstat" read_proc_pid_stat()
    // https://github.com/sysstat/sysstat/blob/master/pidstat.c#L356
    char pid_stat_fname[PATH_MAX+1];
    int  pid_stat_fd;
    char pid_stat_contents[5000];
    int contents_read;

    sprintf(pid_stat_fname, "/proc/%d/stat", process_id);

    if ((pid_stat_fd = open(filename, O_RDONLY)) < 0)
        return -1;

    contents_read = read(fd, pid_stat_contents, sizeof pid_stat_contents - 1);
    close(pid_stat_fd);
    if (contents_read <= 0)
       return -2;
    pid_stat_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/stat" till a field after "cstime"
    // (http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_stat_contents,
           "%*d %*s %*c %*d %*d %*d "    // (1) pid ... till ... (6) session
           "%*d %*d %*u %*lu %*lu %*lu " // (7) tty_nr .. till .. (12) majflt
           "%*lu %lu %lu %ld %ld %*ld ", // (13) cmajflt .till .. (18) priority
           &utime, &stime, &cutime, &cstime);

    if (rd != 4)   // couldn't read the four fields above
        return -3;
    else
        return (utime + stime + cutime + cstime);   // we could split these
                          // values if the load balancer were to be interested
                          // in, e.g., specifically the user time "utime" spent
                          // by this backend process, or the kernel time
                          // "stime" spent by it.
}

static
long
get_os_uptime(void) {
    struct sysinfo kern_info;
    int result = sysinfo(&kern_info);
    if (result != 0)
        return -1;
    else
        return s_info.uptime;
}

static
unsigned long long
get_pid_start_time_ticks(int process_id) {

    unsigned long long start_time_ticks;

    char pid_stat_fname[PATH_MAX+1];
    int  pid_stat_fd;
    char pid_stat_contents[5000];
    int contents_read;

    sprintf(pid_stat_fname, "/proc/%d/stat", process_id);

    if ((pid_stat_fd = open(filename, O_RDONLY)) < 0)
        return 0;

    contents_read = read(fd, pid_stat_contents, sizeof pid_stat_contents - 1);
    close(pid_stat_fd);
    if (contents_read <= 0)
       return 0;
    pid_stat_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/stat" till a field after
    // "starttime" (which itself is the field #22 according to
    // doc: http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_stat_contents,
           "%*d %*s %*c %*d %*d %*d "    // (1) pid ... till ... (6) session
           "%*d %*d %*u %*lu %*lu %*lu " // (7) tty_nr .. till .. (12) majflt
           "%*lu %*lu %*lu %*ld %*ld %*ld "  // (13) cmajflt till (18) priority
           "%*ld %*ld %*ld %llu %*lu ", // (19) nice ... till ... (23) vsize
           &start_time_ticks);

    if (rd != 1)   // couldn't read the field above
        return 0;
    else
        return start_time_ticks;
}


/** Initializes the dynamicRatioProcess module */
void
init_dynamicRatioProcess(void)
{
    const oid dynamicRatioProcessCpu_oid[] = { 1,3,6,1,4,1,99999,3,1 };
    const oid dynamicRatioProcessMemory_oid[] = { 1,3,6,1,4,1,99999,3,2 };

  DEBUGMSGTL(("dynamicRatioProcess", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessCpu", handle_dynamicRatioProcessCpu,
                               dynamicRatioProcessCpu_oid, OID_LENGTH(dynamicRatioProcessCpu_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessMemory", handle_dynamicRatioProcessMemory,
                               dynamicRatioProcessMemory_oid, OID_LENGTH(dynamicRatioProcessMemory_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_dynamicRatioProcessCpu(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            /* TODO: update CPU backend process metric in
             *       struct my_backend_process_metrics above from the local
             *       /proc/<backend_pid>/stat file.
             *       For other metrics, it may be necessary to query other
             *       APIs, like for cluster-wide metrics/recommendations
             *       from Kubernetes Metrics API, DRS, etc, waiting
             *       probably N minutes before refreshing our internal
             *       values from these systems, which don't update their
             *       metrics every 10-20 seconds that the load balancer
             *       queries for the current dynamic metrics. */
            int pid = 1;   // Placeholder "pid = 1"
                           // TODO: find the real process-ID of the backend
                           //       process that the load-balancer is
                           //       interested in to find its CPU availability.

            long long pid_cpu_usage_ticks = get_pid_cpu_stats(pid);

            // these two calls down here, we don't need to call them each
            // time that "handle_dynamicRatioProcessCpu" is called for an
            // SNMP GET request, since they are constant after initialization
            long os_uptime = get_os_uptime();
            long hertz = sysconf(_SC_CLK_TCK);
            // TODO: ERROR checking: if (os_uptime < 0) ERROR

            // this call below is not necesarily constant, since the "pid" may
            // die and another "pid" (process), for the same backend program,
            // may start. Ie., the "pid" may change across calls to
            // "handle_dynamicRatioProcessCpu"
            unsigned long long pid_start_time_ticks =
                                              get_pid_start_time_ticks(pid);
            // TODO: ERROR checking: if (pid_start_time_ticks == 0) ERROR

            // how long this process has been running (in seconds)
            long running_seconds = os_uptime - (pid_start_time_ticks / hertz);

            int pid_cpu_usage_percentage = 100 *
                            ((pid_cpu_usage_ticks / hertz) / running_seconds);
            // TODO: the above two calculations find the CPU% used by the
            // "pid" since the beginning of thee program. Pbby another way
            // would be to find the CPU% used by the process _since_ the last
            // call to this function "handle_dynamicRatioProcessCpu", since it
            // is supposed that the Load-Balancer took some decision on how
            // much traffic to send to this backend process since the last call
            // to this (SNMP) function (using dynamic weighted round-robin).
            // If "pid" has changed since the last call to this function, or if
            // this is the first time that this function has ever been called,
            // then we would use the above value "pid_cpu_usage_percentage".

            // TODO: We can't truly use assert() here because this is a
            // Net-SNMP .SO extension, but in idea:
            //
            // assert( 0 <= pid_cpu_usage_percentage );
            // assert( pid_cpu_usage_percentage <= 100 );

            my_backend_process_metrics.metric_cpu =
                                             (u_long) pid_cpu_usage_percentage;

            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_cpu,
                         sizeof(my_backend_process_metrics.metric_cpu));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessCpu\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_dynamicRatioProcessMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            /* TODO: update memory backend process metric, reading
             *       /proc/<backend_pid>/{status,statm,maps,smaps}.
             *       See also as well comment for the CPU backend process
             *       metric. */
            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_memory,
                         sizeof(my_backend_process_metrics.metric_memory));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessMemory\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
