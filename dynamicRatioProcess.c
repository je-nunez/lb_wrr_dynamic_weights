/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <linux/limits.h>
#include <linux/kernel.h>
#include <regex.h>
#include <stdbool.h>
#include <sys/sysinfo.h>
#include <unistd.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/library/container.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/snmp_logging.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/output_api.h>

#include "dynamicRatioProcess.h"

static int counter_regexps_on_process_cmd_line = 0;

static regex_t regexps_on_proc_cmd_line[MAX_NUMBER_REGEXPS_ON_PROC_CMD_LINE];

static
void config_handle_LbDWRRregexpCmdLine(const char *key, char *value) {
    if (strcasecmp(CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE, key) != 0)
        return;

    if (counter_regexps_on_process_cmd_line >=
              MAX_NUMBER_REGEXPS_ON_PROC_CMD_LINE) {
        snmp_log(LOG_WARNING,
                 "Too many regexps requested in snmpd.conf for '"
                 CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE
                 "'. Ignoring regexps after maximum allowable: %d\n",
                 MAX_NUMBER_REGEXPS_ON_PROC_CMD_LINE);
        return;
    }
    int res = regcomp(
                &regexps_on_proc_cmd_line[counter_regexps_on_process_cmd_line],
                value, REG_EXTENDED|REG_NOSUB
              );
    if (res != 0) {
        snmp_log(LOG_WARNING,
                 "Invalid regexp number %d in option '"
                 CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE
                 "' in snmpd.conf: '%s'. Stopped loading more regexps.\n",
                 counter_regexps_on_process_cmd_line + 1,
                 value);
        return;
    }

    // If regcomp() was successful, then increment the counter
    counter_regexps_on_process_cmd_line ++;
}

static
void config_free_LbDWRRregexpCmdLine(void) {

    for (int i=0; i < counter_regexps_on_process_cmd_line; i++) {
        regfree(&regexps_on_proc_cmd_line[i]);
    }

    counter_regexps_on_process_cmd_line = 0;
}


/** Initializes the dynamicRatioProcess .SO module for the SNMPD agent */
void
init_dynamicRatioProcess(void)
{
    // Change here to use another SNMP OID instead of, for example,
    // [snmpget] 1.3.6.1.4.1.99999.3.1.0 for getting the CPU metric to the
    // load balancer.
    const oid dynamicRatioProcessCpu_oid[] = { 1,3,6,1,4,1,99999,3,1 };
    const oid dynamicRatioProcessMemory_oid[] = { 1,3,6,1,4,1,99999,3,2 };

  DEBUGMSGTL(("dynamicRatioProcess", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessCpu",
                               handle_dynamicRatioProcessCpu,
                               dynamicRatioProcessCpu_oid,
                               OID_LENGTH(dynamicRatioProcessCpu_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessMemory",
                               handle_dynamicRatioProcessMemory,
                               dynamicRatioProcessMemory_oid,
                               OID_LENGTH(dynamicRatioProcessMemory_oid),
                               HANDLER_CAN_RONLY
        ));

    snmpd_register_config_handler(
        CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE,
        config_handle_LbDWRRregexpCmdLine,
        config_free_LbDWRRregexpCmdLine,
        CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE " <extend-reg-expr>"
        "\n\n"
        "# Specify a extended regular expression to match on the process' "
        "command-line to identify\n"
        "# only those processes to report to the load-balancer for its "
        "dynamic weighted round-robin.\n"
        "# That extended regular expression will be matched on any substring "
        "in /proc/*/cmdline.\n"
        "# " CONFIG_TOKEN_REGEXP_ON_PROC_CMD_LINE " can be specified multiple "
        "times, meaning to match\n"
        "# at least any of the reg-exprs indicated."
    );
}


// TODO: Review backend process metrics. These also include contextual
//       metrics about the health of the container, virtual machine
//       and/or hypervisor, like using Kubernetes Metrics API or
//       from DRS.
static struct backend_process_metrics {
    u_long   metric_cpu;
    u_long   metric_memory;
    // ... other metrics (weights) relevant for the dynamic weighted round
    // robin in the load balancer.

    // struct timespec last_time_updated;
    // "last_time_updated" is to avoid querying backend information sources
    // which don't update its information 10-20 second like the load balancer
    // queries these weights, but only every N minutes, like DRS (5 minutes
    // by default)
} my_backend_process_metrics;

struct processes_matching_regexps {
    int count_pids;
    pid_t* matching_pids;
};

static
bool pid_matches_any_regexp(pid_t pid) {

    bool ret_result = false;

    char pid_cmdline[PATH_MAX+1];
    sprintf(pid_cmdline, "/proc/%d/cmdline", pid);
    int  pid_cmdline_fd;
    if ((pid_cmdline_fd = open(pid_cmdline, O_RDONLY)) < 0)
         return false;

    long arg_max = sysconf(_SC_ARG_MAX);
    char* cmdline_buffer = (char*) malloc((arg_max+1) * sizeof(char));
    int contents_read;

    contents_read = read(pid_cmdline_fd, cmdline_buffer, arg_max);
    close(pid_cmdline_fd);
    if (contents_read <= 0) goto func_exit; // we need to free(cmdline_buffer)

    // convert '\0' separating tokens in /proc/<pid>/cmdline to spaces
    for (int i=0; i < contents_read - 1; i++)
        if (cmdline_buffer[i] == '\0') cmdline_buffer[i] = ' ';

    for(int regexp = 0; regexp < counter_regexps_on_process_cmd_line;
            regexp++ ) {

        int res = regexec(&regexps_on_proc_cmd_line[regexp],
                          cmdline_buffer, 0, NULL, 0);
        if (res == 0) { // regular expression matched
            ret_result = true;
            break;
        }
    }

  func_exit:
    free(cmdline_buffer);

    return ret_result;
}

static
struct processes_matching_regexps get_pids_matching_regexps(void) {

    struct processes_matching_regexps ret_result = {
               .count_pids = 0,
               .matching_pids = NULL
    };

    DIR* proc_dir = opendir("/proc");

    if (proc_dir == NULL) {
        snmp_log(LOG_ERR,
                 "Could not open /proc directory in this Linux system.\n");
        return ret_result;
    }

    struct dirent* dir_entry;

    int size_arr = 10, count_elems = 0;
    pid_t* matching_pids = (pid_t*)calloc(size_arr, sizeof(pid_t));
    if (matching_pids == NULL) {
        snmp_log(LOG_ERR,
                 "Could not allocate memory with calloc() at %s@%s\n",
                 __func__, __FILE__);
        return ret_result;
    }

    while ( (dir_entry = readdir(proc_dir)) ) {
        if(dir_entry->d_type != DT_DIR || !isdigit(dir_entry->d_name[0]))
            continue;

        pid_t pid = strtol(dir_entry->d_name, NULL, 10);
        if (pid == 0 || errno == ERANGE)
            continue;

        if (pid_matches_any_regexp(pid)) {
           if (count_elems >= size_arr) {
               size_arr += 10;
               pid_t* new_pids = (pid_t*) realloc(matching_pids,
                                                  size_arr * sizeof(pid_t));
               if (new_pids == NULL) {
                   snmp_log(LOG_ERR,
                       "Could not reallocate memory with realloc() at %s@%s\n",
                       __func__, __FILE__);
                   free(matching_pids);
                   return ret_result;
               }
               matching_pids = new_pids;
               for (int i=count_elems; i<size_arr; i++)
                   matching_pids[i] = 0;
           }
           matching_pids[count_elems++] = pid;
        }
    }
    closedir(proc_dir);

    ret_result.count_pids = count_elems;
    ret_result.matching_pids = matching_pids;

    return ret_result;
}

static
long
get_pid_cpu_stats(pid_t process_id) {

    unsigned long utime;   // the signed or unsigned long is given by...
    unsigned long stime;   // format specifier %lu or %ld in proc(5) ...
    long          cutime;  // (`man 5 proc` for "/proc/[pid]/stat")
    long          cstime;

    // Inspired by Sebastien Godard's "pidstat" read_proc_pid_stat()
    // https://github.com/sysstat/sysstat/blob/master/pidstat.c#L356
    char pid_stat_fname[PATH_MAX+1];
    int  pid_stat_fd;
    char pid_stat_contents[5000];
    int contents_read;

    sprintf(pid_stat_fname, "/proc/%d/stat", process_id);

    if ((pid_stat_fd = open(pid_stat_fname, O_RDONLY)) < 0)
        return -1;

    contents_read = read(pid_stat_fd, pid_stat_contents,
                         sizeof pid_stat_contents - 1);
    close(pid_stat_fd);
    if (contents_read <= 0)
       return -2;
    pid_stat_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/stat" till a field after "cstime"
    // (http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_stat_contents,
           "%*d %*s %*c %*d %*d %*d "    // (1) pid ... till ... (6) session
           "%*d %*d %*u %*u %*u %*u " // (7) tty_nr .. till .. (12) majflt
           "%*u %lu %lu %ld %ld %*d ", // (13) cmajflt .till .. (18) priority
           &utime, &stime, &cutime, &cstime);

    if (rd != 4)   // couldn't read the four fields above
        return -3;
    else
        return (utime + stime + cutime + cstime);   // we could split these
                          // values if the load balancer were to be interested
                          // in, e.g., specifically the user time "utime" spent
                          // by this backend process, or the kernel time
                          // "stime" spent by it.
}

static
long
get_os_uptime(void) {
    struct sysinfo kern_info;
    int result = sysinfo(&kern_info);
    if (result != 0) {
        snmp_log(LOG_ERR, "Call to sysinfo() failed, %s@%s\n",
                 __func__, __FILE__);
        return -1;
    } else
        return kern_info.uptime;
}

static
unsigned long long
get_pid_start_time_ticks(pid_t process_id) {

    unsigned long long start_time_ticks;

    char pid_stat_fname[PATH_MAX+1];
    int  pid_stat_fd;
    char pid_stat_contents[5000];
    int contents_read;

    sprintf(pid_stat_fname, "/proc/%d/stat", process_id);

    if ((pid_stat_fd = open(pid_stat_fname, O_RDONLY)) < 0) {
        snmp_log(LOG_WARNING, "Could not open file %s\n", pid_stat_fname);
        return 0;
    }

    contents_read = read(pid_stat_fd, pid_stat_contents,
                         sizeof pid_stat_contents - 1);
    close(pid_stat_fd);
    if (contents_read <= 0) {
       snmp_log(LOG_WARNING, "Could not read from file %s\n", pid_stat_fname);
       return 0;
    }
    pid_stat_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/stat" till a field after
    // "starttime" (which itself is the field #22 according to
    // doc: http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_stat_contents,
           "%*d %*s %*c %*d %*d %*d "    // (1) pid ... till ... (6) session
           "%*d %*d %*u %*u %*u %*u " // (7) tty_nr .. till .. (12) majflt
           "%*u %*u %*u %*d %*d %*d "  // (13) cmajflt till (18) priority
           "%*d %*d %*d %llu %*u ", // (19) nice ... till ... (23) vsize
           &start_time_ticks);

    if (rd != 1) {  // couldn't read the field above
       snmp_log(LOG_WARNING, "Could not parse file %s\n", pid_stat_fname);
       return 0;
    } else
       return start_time_ticks;
}

/*
 * Returns the RSS size (in KB) of a process-id. If there is an error, it
 * returns a negative number instead.
 */

static
long
get_pid_rss_mem_kb(pid_t process_id) {

    long rss_mem_pages;

    char pid_statm_fname[PATH_MAX+1];
    int  pid_statm_fd;
    char pid_statm_contents[5000];
    int contents_read;

    sprintf(pid_statm_fname, "/proc/%d/statm", process_id);

    if ((pid_statm_fd = open(pid_statm_fname, O_RDONLY)) < 0) {
        snmp_log(LOG_WARNING, "Could not open file %s\n", pid_statm_fname);
        return -1;
    }

    contents_read = read(pid_statm_fd, pid_statm_contents,
                         sizeof pid_statm_contents - 1);
    close(pid_statm_fd);
    if (contents_read <= 0) {
       snmp_log(LOG_WARNING, "Could not read from file %s\n", pid_statm_fname);
       return -2;
    }
    pid_statm_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/statm" till a field after "resident"
    // (ie., till the field "shared")
    // doc: http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_statm_contents,
           "%*d %ld %*d ",   // (1) size (2) resident (3) shared
           &rss_mem_pages);

    if (rd != 1) {  // couldn't read the field above
        snmp_log(LOG_WARNING, "Could not parse file %s\n", pid_statm_fname);
        return -3;
    } else {
        long bytes_in_page = sysconf(_SC_PAGESIZE);
        return (rss_mem_pages * bytes_in_page / 1024);
    }
}


/*
 * Returns the available memory (in KB) in Linux. If there is an error, it
 * returns a negative number instead.
 *
 * About /proc/meminfo (in `man 5 proc`):
 *
 *    Field:
 *
 *         MemAvailable %lu (since Linux 3.14)
 *
 *              An estimate of how much memory is available for starting new
 *              applications, ____without swapping____.
 *
 *              (___Underscore___ above is ours, since it is relevant for the
 *               load-balancer to know when to send requests to a backend
 *               process ___without making it swap___.)
 *
 * The `free` program returns the field "MemFree" in the "free" column, and
 * and returns the field "MemAvailable" in the "available" column.
 *
 * The field "MemAvailable" in /proc/meminfo exists since Linux kernel version
 * 3.14 (released on 30 March 2014) or higher, and some major distributions
 * don't release yet with this kernel version by default.
 *
 * So we prefer to use the field "MemAvailable" in /proc/meminfo if it is found
 * there. If it is not found, then use the field "MemFree". An alternative is
 * to call "uname(struct utsname *buf)" to check the version of kernel, and if
 * it is >= 3.14, then to search for "MemAvailable" in /proc/meminfo, otherwise
 * to search for "MemFree".
 */

static
long
get_linux_avail_mem_kb(void) {

    long avail_mem_kb = -1;
    FILE * proc_meminfo;
    char line[256];

    if ((proc_meminfo = fopen("/proc/meminfo", "r")) == NULL) {
        snmp_log(LOG_ERR,
                 "Could not open /proc/meminfo in this Linux system.\n");
        return -2;
    }

    while (fgets(line, sizeof(line), proc_meminfo)) {
        bool this_is_mem_avail = false; // if this is "MemAvailable: "
        char * token_start;             // start of the field-name token
        if ((token_start = strstr(line, "MemAvailable: ")) != NULL) {
            this_is_mem_avail = true;
        } else {
            token_start = strstr(line, "MemFree: ");
        }
        if (token_start == NULL)
            continue;   // another token we are not interested in
        else if (token_start != line)
            continue;  // the token was found, but not at the start of line

        // skip the token (field-name) till the first space following it
        for (; *token_start != '\0' && *token_start != ' '; token_start ++);
        // then skip all the spaces before the numeric value
        for (; *token_start != '\0' && *token_start == ' '; token_start ++);

        long value;
        int rd = sscanf(token_start, "%ld", &value);
        if (rd != 1)   // couldn't read the numeric field above
            continue;  // skip this line
        // skip the digits of the value
        for (; *token_start != '\0' && isdigit(*token_start); token_start ++);
        // skip the spaces before the [optional] unit of measurement
        for (; *token_start != '\0' && *token_start == ' '; token_start ++);

        // try to understand the [optional] unit of measurement of the value
        if (*token_start == 'm' || *token_start == 'M')       // MBs
            avail_mem_kb = value * 1024;
        else if (*token_start == 'g' || *token_start == 'G')  // GBs
            avail_mem_kb = value * 1024 * 1024;
        if (*token_start == 'k' || *token_start == 'K' || // KBs, or
            *token_start == '\n' || *token_start == '\0') // no unit of measure
            avail_mem_kb = value;     // KBs is the default unit, if omitted
        else {
            snmp_log(LOG_CRIT,
                     "We have found a yet-unprocessed unit of measure in "
                     "/proc/meminfo, line: '%s'\n",
                     line);
            continue;
        }

        if (this_is_mem_avail)
            break;     // the value of "MemAvailable:" is immediately good
    }

    fclose(proc_meminfo);
    return avail_mem_kb;
}


int
handle_dynamicRatioProcessCpu(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            ;
            /* TODO: update CPU backend process metric in
             *       struct my_backend_process_metrics above from the local
             *       /proc/<backend_pid>/stat file.
             *       For other metrics, it may be necessary to query other
             *       APIs, like for cluster-wide metrics/recommendations
             *       from Kubernetes Metrics API, DRS, etc, waiting
             *       probably N minutes before refreshing our internal
             *       values from these systems, which don't update their
             *       metrics every 10-20 seconds that the load balancer
             *       queries for the current dynamic metrics. */

            int total_cpu_usage_percentage = 0;

            // this call down here, we don't need to call it each time that
            // "handle_dynamicRatioProcessCpu" is called for an SNMP GET
            // request, since it is constant after initialization
            long hertz = sysconf(_SC_CLK_TCK);

            long os_uptime = get_os_uptime();
            if (os_uptime < 0) goto return_value_to_snmp;

            struct processes_matching_regexps matching_pids =
                   get_pids_matching_regexps();

            for (int i=0; i<matching_pids.count_pids; i++) {
                pid_t pid = matching_pids.matching_pids[i];
                long pid_cpu_usage_ticks = get_pid_cpu_stats(pid);

                // this call below is not necesarily constant, since the "pid"
                // may die and another "pid" (process), for the same backend
                // program, may start. Ie., the "pid" may change across calls
                // to "handle_dynamicRatioProcessCpun
                unsigned long long pid_start_time_ticks =
                                              get_pid_start_time_ticks(pid);
                if (pid_start_time_ticks == 0)
                    continue;    // ignore this pid. Errors logged by callee

                // how long this process has been running (in seconds)
                long running_seconds =
                                os_uptime - (pid_start_time_ticks / hertz);

                int pid_cpu_usage_percentage =
                     (( 100 * pid_cpu_usage_ticks) / hertz) / running_seconds;

                // TODO: the above two calculations found the CPU% used by the
                // "pid" _since the beginning of thee program_. Pbby another
                // way would be to find the CPU% used by the process _since_
                // the last call to this function
                // "handle_dynamicRatioProcessCpu", since it is supposed that
                // the Load-Balancer took some decision on how much traffic to
                // send to this backend process since the last call to this
                // (SNMP) function (using dynamic weighted round-robin). This
                // second alternative of the formula doesn't calculate the
                // CPU%, but the first-derivative in time of the CPU% since
                // last sample, to see how the Load-Balancer decisions have
                // affected the load of this backend process. Note: If "pid"
                // has changed since the last call to this function so it is
                // a completely new "pid" we ever see, or if this is the first
                // time that this function here has ever been called, then to
                // find a first derivative has no sense yet for this first
                // time.

                total_cpu_usage_percentage += pid_cpu_usage_percentage;
            }

            free(matching_pids.matching_pids);

            // TODO: We can't truly use assert() here because this is a
            // Net-SNMP .SO extension, but in idea:
            // int num_processors = get_nprocs_conf();
            // assert( 0 <= total_cpu_usage_percentage );
            // assert( total_cpu_usage_percentage <= 100 * num_processors );

       return_value_to_snmp:

            my_backend_process_metrics.metric_cpu =
                                           (u_long) total_cpu_usage_percentage;

            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_cpu,
                         sizeof(my_backend_process_metrics.metric_cpu));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessCpu\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dynamicRatioProcessMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            ;
            /* TODO: update memory backend process metric, reading
             *       /proc/<backend_pid>/{status,statm,maps,smaps}.
             *       See also as well comment for the CPU backend process
             *       metric. */

            // we can either return to the load-balancer the memory size of
            // the process (so the bigger the backend process, probably the
            // less its weight in the load-balancer -if the load-balancer
            // gives any weight to the memory size of the backend process);
            // OR:
            // return the available memory in the (Linux) system (so the more
            // the memory still available, then the higher weight this backend
            // process should have in the load-balancer, all other dimensions
            // being the same). NOTE: This second for is irrelevant for
            // JVM -alike- backend processes with max heap size "-Xmx", or with
            // backend processes with a memory-limit (ulimit -v ...), or
            // running under a Linux control group, "cgcreate -g memory:..."

            long return_value = 0;

#ifdef FIND_MEMORY_METRIC_ONLY_BY_AVAILABLE_MEM
            long system_avail_mem_kb = get_linux_avail_mem_kb(); // we don't
                                 // need to iterate on the matching pids with
                                 // this second alternative through
                                 // "get_linux_avail_mem_kb()"
            return_value = system_avail_mem_kb;
#else
            long total_rss_mem_usage_kb = 0;

            struct processes_matching_regexps matching_pids =
                   get_pids_matching_regexps();

            for (int i=0; i<matching_pids.count_pids; i++) {
                pid_t pid = matching_pids.matching_pids[i];
                long rss_pid_kb = get_pid_rss_mem_kb(pid);  // the RSS (in KB)
                if (rss_pid_kb < 0)
                    continue;    // ignore this pid. Errors logged by callee
                total_rss_mem_usage_kb += rss_pid_kb;
            }

            free(matching_pids.matching_pids);
            return_value = total_rss_mem_usage_kb;
#endif

            my_backend_process_metrics.metric_memory = return_value;

            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_memory,
                         sizeof(my_backend_process_metrics.metric_memory));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessMemory\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
