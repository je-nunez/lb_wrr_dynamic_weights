/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dynamicRatioProcess.h"


// TODO: Review backend process metrics. These also include contextual
//       metrics about the health of the container, virtual machine
//       and/or hypervisor, like using Kubernetes Metrics API or
//       from DRS.
static struct backend_process_metrics {
    u_long   metric_cpu;
    u_long   metric_memory;
    // ... other metrics (weights) relevant for the dynamic weighted round
    // robin in the load balancer.

    // struct timespec last_time_updated;
    // "last_time_updated" is to avoid querying backend information sources
    // which don't update its information 10-20 second like the load balancer
    // queries these weights, but only every N minutes, like DRS (5 minutes
    // by default)
} my_backend_process_metrics;


static
long long
get_pid_cpu_stats(int process_id) {

    unsigned long long utime;   // the signed or unsigned long is given by...
    unsigned long long stime;   // format specifier %lu or %ld in proc(5) ...
    long long          cutime;  // (`man 5 proc` for "/proc/[pid]/stat")
    long long          cstime;

    // Inspired by Sebastien Godard's "pidstat" read_proc_pid_stat()
    // https://github.com/sysstat/sysstat/blob/master/pidstat.c#L356
    char pid_stat_fname[PATH_MAX+1];
    int  pid_stat_fd;
    char pid_stat_contents[5000];
    int contents_read;

    sprintf(pid_stat_fname, "/proc/%d/stat", process_id);

    if ((pid_stat_fd = open(filename, O_RDONLY)) < 0)
        return -1;

    contents_read = read(fd, pid_stat_contents, sizeof pid_stat_contents - 1);
    close(pid_stat_fd);
    if (contents_read <= 0)
       return -2;
    pid_stat_contents[contents_read] = '\0';

    // scan the beginning of "/proc/%d/stat" till a field after "cstime"
    // (http://man7.org/linux/man-pages/man5/proc.5.html)
    int rd;
    rd = sscanf(
           pid_stat_contents,
           "%*d %*s %*c %*d %*d %*d "    // (1) pid ... till ... (6) session
           "%*d %*d %*u %*lu %*lu %*lu " // (7) tty_nr .. till .. (12) majflt
           "%*lu %lu %lu %ld %ld %*ld ", // (13) cmajflt .till .. (18) priority
           &utime, &stime, &cutime, &cstime);

    if (rd != 4)   // couldn't read the four fields above
        return -3;
    else
       return (utime + stime + cutime + cstime);   // we could split these
                          // values if the load balancer were to be interested
                          // in, e.g., specifically the user time "utime" spent
                          // by this backend process, or the kernel time
                          // "stime" spent by it.
}


/** Initializes the dynamicRatioProcess module */
void
init_dynamicRatioProcess(void)
{
    const oid dynamicRatioProcessCpu_oid[] = { 1,3,6,1,4,1,99999,3,1 };
    const oid dynamicRatioProcessMemory_oid[] = { 1,3,6,1,4,1,99999,3,2 };

  DEBUGMSGTL(("dynamicRatioProcess", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessCpu", handle_dynamicRatioProcessCpu,
                               dynamicRatioProcessCpu_oid, OID_LENGTH(dynamicRatioProcessCpu_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dynamicRatioProcessMemory", handle_dynamicRatioProcessMemory,
                               dynamicRatioProcessMemory_oid, OID_LENGTH(dynamicRatioProcessMemory_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_dynamicRatioProcessCpu(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            /* TODO: update CPU backend process metric in
             *       struct my_backend_process_metrics above from the local
             *       /proc/<backend_pid>/stat file.
             *       For other metrics, it may be necessary to query other
             *       APIs, like for cluster-wide metrics/recommendations
             *       from Kubernetes Metrics API, DRS, etc, waiting
             *       probably N minutes before refreshing our internal
             *       values from these systems, which don't update their
             *       metrics every 10-20 seconds that the load balancer
             *       queries for the current dynamic metrics. */
            int pid = 1;   // Placeholder "pid = 1"
                           // TODO: find the real process-ID of the backend
                           //       process that the load-balancer is
                           //       interested in to find its CPU availability.

            long long pid_cpu_usage = get_pid_cpu_stats(pid);

            // TODO: convert "pid_cpu_usage" above to a metric
            //       "my_backend_process_metrics.metric_cpu" the load-balancer
            //       can understand for its dynamic weighted round roubin in
            //       the LB pool of backend-processes.

            // my_backend_process_metrics.metric_cpu = ...

            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_cpu,
                         sizeof(my_backend_process_metrics.metric_cpu));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessCpu\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_dynamicRatioProcessMemory(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            /* TODO: update memory backend process metric, reading
             *       /proc/<backend_pid>/{status,statm,maps,smaps}.
             *       See also as well comment for the CPU backend process
             *       metric. */
            snmp_set_var_typed_value(requests->requestvb,
                         ASN_INTEGER,
                         (u_char *) &my_backend_process_metrics.metric_memory,
                         sizeof(my_backend_process_metrics.metric_memory));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dynamicRatioProcessMemory\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
